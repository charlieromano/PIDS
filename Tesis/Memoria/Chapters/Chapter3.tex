\chapter{Diseño e implementación} % Main chapter title
\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este capítulo, se abordan cuestiones de diseño, se presentan los requerimientos del sistema y se describe la solución propuesta. Se detalla la solución en términos de arquitectura, patrones de software, descripción de componentes e implementación. En el desarrollo, se utiliza la plataforma de hardware EDU-CIAA \citep{CIAA}, la API Firmware\_ v3 \citep{firmwarev3}, y freeRTOS \citep{freeRTOS} como sistema operativo de tiempo real.\\

% Siguiendo lineamientos de ingeniería de software, se presentan los requerimientos, funcionalidades y casos de uso como ejes principales del espacio problema. Luego se presenta la arquitectura, la organización del código fuente, los patrones implementados, diagramas de secuencia y diagramas de interacción entre componentes como detalle del espacio solución.\\


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.95,0.95,0.95}
\definecolor{mygray50}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parámetros para configurar el formato del código en los entornos lstlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{ %
  backgroundcolor=\color{mygray},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars,=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,                % the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray50}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}
}
\lstdefinestyle{nonumbers}
{numbers=none}
  


\section{Requerimientos}

 El objetivo principal de este trabajo es diseñar e implementar un sistema de información visual para pasajeros a bordo del tren. Está dirigido a:
\begin{enumerate}
\item Todos los  miembros del grupo de trabajo GICSAFE y SOFSE que participan de proyectos orientados a cubrir necesidades tecnológicas del sistema ferroviario argentino.
\item Alumnos y personal académico con intenciones de participar en proyectos de desarrollo aplicados a la industria.
\item Desarrolladores de software y equipamiento para trenes.
\end{enumerate}

A nivel general, los requerimientos del proyecto son los siguientes:

\begin{itemize}

\item El sistema debe leer datos de información al pasajero de la red interna de los trenes y presentarlos en un display led. El sistema no se encargará de presentar los mensajes en formato de audio.

\item El sistema permitirá implementar las funciones de visualización del sistema de información al pasajero existente. La solución existente es un sistema propietario que integra también un sistema de audio, un CCTV usando cámaras de seguridad, entre otras funcionalidades. 

\item El sistema que se especifica busca desacoplar funciones del equipamiento propietario para permitir realizar tareas de mantenimiento. Como ejemplo, la reposición de carteles led que en la actualidad quedan fuera de servicio por fallas o pérdida del material original y que no pueden ser reparados. 

\end{itemize}

Estos requerimientos generales se traducen en requerimientos específicos y se dividen en tres grupos que se detallan a continuación: requerimientos funcionales, de integración y de documentación. \\

\pagebreak

\textbf{Requerimientos funcionales}

\begin{itemize}
\item El sistema debe controlar arreglos de matrices led de 8x8 (64 leds individuales).
\item El sistema debe presentar en el display información dinámicamente.
\item El sistema debe poder almacenar una cantidad de información para visualización.
\item El sistema debe permitir elegir entre distintos mensajes de visualización.
\item El sistema debe permitir cargar los mensajes a visualizar a través de una computadora.
\item El sistema debe poder reaccionar a un mensaje que es enviado para visualizar.
\end{itemize}

\textbf{Requerimientos de integración con la red TCN
}\begin{itemize}
\item Las placas de control deben ser compatibles con el sistema PIDS existente.
\item Las placas de control deben poder alimentarse con 110 VDC.
\item El bus de datos de entrada debe ser una interfaz RS-485.
\item El sistema debe interpretar las tramas del PIDS que corresponden a los módulos LDU.
\item El sistema debe manejar tramas en ciclos típicos de 16-20 ms.
\end{itemize}

\textbf{Requerimientos de documentación
}\begin{itemize}
\item Se debe generar un documento de casos de prueba.
\item Se debe generar una guía de usuario.
\item Se debe generar una presentación del sistema.
\item Se debe generar un informe final de proyecto.
\end{itemize}

La tabla \ref{tab:Reqs} sintetiza los requerimientos y les asigna un código de referencia para la evaluación de su cumplimiento.
	
\begin{table}[htb]
\caption{Tabla de requerimientos funcionales, de integración y de documentación del trabajo.}
\label{tab:Reqs}
\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Código} & \textbf{Descripción}                                 \\ \midrule
PIDS-REQ-FN-01  & Control de módulos de matriz led 8x8.                 \\ \hline
PIDS-REQ-FN-02  & Control de paneles de 2x6 modulos.                    \\ \hline
PIDS-REQ-FN-03  & Control de displays basados en arreglos de 3 paneles. \\ \hline
PIDS-REQ-FN-04  & Visualización de mensajes en idioma castellano.       \\ \hline
PIDS-REQ-FN-05  & Visualización de mensajes dinámicos.                  \\ \hline
PIDS-REQ-FN-06  & Almacenamiento de información de trayecto.            \\ \hline
PIDS-REQ-FN-07  & Selección de contenidos disponibles.                  \\ \hline
PIDS-REQ-FN-08  & Upstream de mensajes desde una computadora personal.  \\ \hline
PIDS-REQ-INT-01 & Compatibilidad de sistema con sistema existente.      \\ \hline
PIDS-REQ-INT-02 & Compatibilidad eléctrica.                             \\ \hline
PIDS-REQ-INT-03 & Compatibilidad de interfaces RS485.                   \\ \hline
PIDS-REQ-INT-04 & Compatibilidad con tramas de datos del módulo LDU.    \\ \hline
PIDS-REQ-INT-05 & Procesamiento de tramas menor a 16 ms.                \\ \hline
PIDS-REQ-DOC-01 & Documentación de casos de prueba.                     \\ \hline
PIDS-REQ-DOC-02 & Guía de usuario.                                      \\ \hline
PIDS-REQ-DOC-03 & Presentación del sistema.                             \\ \hline
PIDS-REQ-DOC-04 & Informe final de proyecto.                            \\ \bottomrule
\end{tabular}
\end{center}
\end{table}


Por último se explicita que para el desarrollo del presente proyecto se asume que:

\begin{itemize}
\item No habrá dependencias directas con otros proyectos enmarcados en el mismo PDE \citep{PDE-TCN}.
\item No habrá dificultad ni excesivas demoras en la compra de los componentes electrónicos o
de software necesarios.
\item Se contará con recursos y materiales necesarios para validar las pruebas realizadas.
Trenes Argentinos dará acceso a una formación ferroviaria con red TCN para realizar
pruebas de campo.
\item El sistema de información al pasajero se va a instalar en el sistema PIDS existente de las formaciones ferroviarias en operación.
\item El sistema de información al pasajero no se va a instalar en redes TCN de tiempo real
basadas en Ethernet (ETB/ECN).
\end{itemize}


\section{Casos de uso}
Los casos de uso planteados se presentan como respuesta a historias de usuario. Las historias de usuario propuestas en este trabajo son:
\begin{itemize}
\item Como usuario del tren, quiero ver el nombre de la estación a la que estoy arribando.
\item Como conductor del tren, quiero elegir el destino y recorrido asociado que se visualizará en los coches.
\item Como sistema vinculado, quiero transmitir mensajes de asistencia, emergencia e información al pasajero.
\item Como componente de sistema, quiero recibir e interpretar tramas de la red de datos del sistema PIDS
\end{itemize}

Estas historias de usuario presentan cuatro tipos distintos de usuarios: pasajeros, conductores, sistemas de información al pasajero y componentes internos del sistema. Con esta variedad de usuarios de sistema, se busca definir funcionalidades y casos de uso. Los principales casos de uso del sistema se presentan en la tabla \ref{tab:UseCases}. \\

\begin{table}[htb]
\caption{Tabla de casos de uso.}
\label{tab:UseCases}
\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Código} & \textbf{Descripción}     \\ 
\midrule
PIDS-UC-01  & Visualizar estación.         \\ \hline
PIDS-UC-02  & Elegir destino.             \\ \hline
PIDS-UC-03  & Información de asistencia. \\ \hline
PIDS-UC-04  & Receptor de tramas.       \\ 
\bottomrule
\end{tabular}
\end{center}
\end{table}

En el caso de uso UC-1, se involucra al tren como sistema disparador cuando arriba a una estación, y se presenta información visual al pasajero usando los carteles led de salón. 

En el caso de uso UC-2, se resuelve una acción del conductor al presionar un botón, y también se presenta información visual al pasajero, en este caso las estaciones cabecera del recorrido que se visualizan en los carteles led de frente y contrafrente del tren. 

El tercer caso de uso, UC-3, presenta información de asistencia cargada previamente, que se dispara por acción de un temporizador mientras el tren está en circulación. 

Por último, el caso de uso UC-4 involucra al módulo SCU (ver figura  \ref{fig:diagramaPIDS} de la red PIDS) y a un sistema externo, como podría ser la computadora de un operador u otro componente de la red. Esto se realiza para codificar las tramas de datos recibidas desde el SCU.\\

\section{Arquitectura del sistema}

El sistema PIDS de Trenes Argentinos es parte de una solución integral de la red TCN del fabricante de los trenes, la empresa China State Railway Group Company, Ltd. En este capítulo, se describen los aspectos más relevantes del sistema PIDS de esa arquitectura y su relación con los componentes del sistema propuesto en este trabajo. El sistema diseñado en este trabajo sigue una arquitectura orientada a eventos. Se desarrollaron e implementaron distintos patrones de software buscando satisfacer propiedades de modularidad, portabilidad y escalabilidad. Algunos de los objetos implementados se describen a nivel de detalle para resaltar criterios y decisiones de diseño relevantes. La relación entre la arquitectura existente del PIDS de trenes y la arquitectura del sistema embebido basado en la plataforma CIAA, busca por un lado satisfacer la compatibilidad eléctrica del hardware, y por otro, las historias de usuario planteadas en los casos de uso, en la etapa de definición de requerimientos. \\

En las secciones siguientes, se describen los componentes del sistema y sus interacciones de manera más detallada. \

\subsection{Contexto de la solución}

El sistema PIDS forma parte de una solución integral: la red de comunicaciones del tren o red TCN. Este sistema proporciona información a los pasajeros y puede ser operado tanto por el conductor del tren como por los operadores. Se representa a nivel sistema con en el diagrama de la figura \ref{fig:diagTrenTcnPids}.\\

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagTrenTcnPids.png}
	\caption{Diagrama del sistema Tren-TCN-PIDS.}
	\label{fig:diagTrenTcnPids}
\end{figure}

La red TCN define una comunicación estándar usando dos buses jerárquicos llamados WTB (\textit{Wire Train Bus}) y MVB (\textit{Multifunction Vehicle Bus}). El sistema PIDS se interconecta al bus de datos MVB, como se indica en el diagrama de la figura \ref{fig:diagTcnPidsBuusesWtbMvb}.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagTcnPidsBusesWtbMvb.png}
	\caption{Diagrama de interconexión TCN-PIDS}
	\label{fig:diagTcnPidsBuusesWtbMvb}
\end{figure}

El sistema PIDS tiene un bus de comunicación propio a través de una red RS485. Uno de los componentes de esta red es el módulo SCU (descrito en la topolgía del PIDS en el capítulo 2), al cual se conectan distintos dispositivos, como los display led, los mapas de recorrido led, las cámaras y los parlantes, tal como se indica en la figura 	\ref{fig:diagPidsScuDevices}.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagPidsScuDevices.png}
	\caption{Diagrama del módulo SCU en la red PIDS.}
	\label{fig:diagPidsScuDevices}
\end{figure}

Al módulo SCU se conectan las unidades IDU, que corresponden a los display led de salón. Cada unidad IDU contiene un controlador (\textit{driver}) y el arreglo de módulos de matriz led que conforman el display. En la figura \ref{fig:diagScuDriverDisplay} se representan estos bloques funcionales.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagScuDriverDisplay.png}
	\caption{Diagrama de bloques del sistema SCU, placa de control y carteles led de salón.}
	\label{fig:diagScuDriverDisplay}
\end{figure}

El alcance del sistema desarrollado en este trabajo cubre la funcionalidad de este conjunto de bloques \textit{Driver + Display}, que en la nomenclatura del sistema PIDS existente corresponde a los módulos IDU. Existen dos unidades de estos módulos por cada salón o coche. Muchas de las formaciones de SOFSE disponen de siete coches, por lo que se tiene un mínimo de catorce unidades IDU (dos por salón), más dos displays externos adicionales para el frente y contrafrente del tren que indican las estaciones cabecera del recorrido. Esto resulta en un total de al menos dieciséis unidades de control de carteles de matriz led por cada tren. Teniendo en cuenta las formaciones operativas de las líneas Mitre, Sarmiento y Roca del Área Metropolitana de Buenos Aires (AMBA), se puede estimar alrededor de treinta trenes operando en simultáneo, lo que resulta en aproximadamente 500 unidades de carteles operando en vivo. El impacto que puede tener el aporte de este trabajo estará directamente relacionado con la operación de Trenes Argentinos, y puede contribuir a la extensión de la vida útil de los trenes.\\

\subsection{Diseño del sistema}

El diseño propuesto tiene como objetivo abordar las funcionalidades del bloque de control del display led. Mientras que el display led es una unidad que se puede adquirir comercialmente, el controlador para la red PIDS es una solución propietaria del fabricante que se pretende reemplazar con este desarrollo. En la figura \ref{fig:diagVistaReDisenhoEduCIAA} se presenta un diagrama de bloques del sistema de control propuesto. Este controlador utiliza la comunicación serie a través de interfaces UART-RS485 y UART-USB. La UART (\textit{Universal Asynchronous Receiver Transmitter}) es un periférico del microcontrolador de la plataforma CIAA. Dado que la alimentación de la CIAA difiere de la existente en la red RS485 de Trenes Argentinos, se requiere un bloque de conversión de tensión DC-DC para garantizar compatibilidad eléctrica. La comunicación con el display se realiza mediante un adaptador eléctrico, que consiste principalmente en un puerto de entrada-salida.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/diagVistaReDisenhoEduCIAA.png}
	\caption{Diagrama de bloques del controlador propuesto.}
	\label{fig:diagVistaReDisenhoEduCIAA}
\end{figure}

A nivel lógico, el sistema que propuesto se compone de cuatro objetos activos que interactúan entre sí, tal como se indica en la figura \ref{fig:diagVistaDisenho}. El prefijo '\underline{ao:}' señala que el bloque es un objeto activo. 
\begin{itemize}
\item El objeto activo UART es el encargado de recibir e interpretar las tramas de datos que viajan por la red RS485 del bus de datos del SCU. 
\item El objeto activo Button es el control manual del operador para accionar el sistema. 
\item El objeto activo PIDS es una máquina de estados que representa el estado del tren, y contiene los mensajes y nombres de las estaciones. 
\item El objeto activo DisplayLed es el encargado de codificar los mensajes en el formato correspondiente a la matriz led del display.\\
\end{itemize}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/diagVistaDisenho.png}
	\caption{Vista estructural del sistema propuesto.}
	\label{fig:diagVistaDisenho}
\end{figure}



Esta vista estructural del sistema describe la interacción entre componentes e indica su dependencia funcional. El diseño modular permite realizar cambios en los componentes de forma independiente. Por ejemplo, se podrían reemplazar los mensajes al pasajero en el objeto PIDS sin afectar el resto del sistema. En caso de ser necesario cambiar el hardware de control, se podría reemplazar la lógica de control del display led modificando únicamente el objeto Displayled.\\


\section{Implementación del sistema embebido}

En este trabajo, se lleva a cabo la implementación de un sistema embebido utilizando el lenguaje de programación C y el sistema operativo de tiempo real freeRTOS. La plataforma de hardware utilizada es la CIAA-EDU-NXP, que dispone de un microcontrolador LPC4337 de la companía NXP \citep{NXPLPC4337}, con una arquitectura de 32 bits ARM Cortex-M4/M0. El firmware se desarrolló utilizando la \textit{SAPI} y el \textit{firmwarev3} \citep{firmwarev3} como capa de abstracción de hardware. Esta API proporciona una interfaz para utilizar las funciones de la biblioteca CMSIS del fabricante del microcontrlador y es un componente fundamental del proyecto CIAA.\\
 
Durante el diseño del sistema, se crearon plantillas para implementar patrones de software, como máquinas de estado y objetos activos. Los aspectos de calidad de software, como documentación, pruebas unitarias, mantenimiento y escalabilidad,  se tuvieron en cuenta desde el diseño, y su implementación se facilitó mediante el uso de estas plantillas. Los lineamientos y fragmentos de código relevantes de estas plantillas son descriptos en la sección de patrones de software. \\

La implementación de los objetos activos se detalla en la sección de componentes de sistema. Los atributos clave de la solución y las interacciones entre los componentes forman parte de la documentación presentada. Paar una comprensión más profunda, la implementación del controlador del diplay led incluye una sección con detalles adicionales. El firmware busca ser portable a aquellas versiones de hardware de display de matriz led que utilicen los conjuntos de chips 74HC245, 74HC595 y 74HC138, o sistemas digitales equivalentes. \\



\subsection{Organización del código fuente}
La organización del código fuente que conforma el sistema embebido de este trabajo se detalla en el siguiente árbol de archivos:

\begin{lstlisting}[caption=Árbol de archivos del código fuente del sistema., language=Bash, 
	backgroundcolor=\color{mygray},
	]
AppRTOS
|-- config.mk
|-- inc
|   |-- common.h
|   |-- displayled.h
|   |-- FreeRTOSConfig.h
|   |-- ISR_GPIO.h
|   |-- ISR_UART.h
|   |-- main.h
|   |-- modulePanelDisplay.h
|   |-- portmap.h
|   |-- statemachine_AB.h
|   |-- statemachine_button.h
|   |-- statemachine_displayled.h
|   |-- statemachine_PIDS.h
|   |-- statemachine_UART.h
|   `-- userTasks.h
|-- LICENSE.txt
`-- src
    |-- displayled.c
    |-- ISR_GPIO.c
    |-- ISR_UART.c
    |-- main.c
    |-- statemachine_AB.c
    |-- statemachine_button.c
    |-- statemachine_displayled.c
    |-- statemachine_PIDS.c
    |-- statemachine_UART.c
    `-- userTasks.c
\end{lstlisting}

Se pueden observar dos directorios principales: \textit{inc} y \textit{src}. En \textit{inc} se incluyen los archivos de encabezados y en \textit{src} los archivos de código ejecutable. Existe un archivo principal o \textit{main} que es el que instancia las secuencias de incialización, recursos y tareas del sistema operativo. Las tareas, que incluyen a los objetos activos y procesos del sistema, se implementan en los archivos \textit{userTasks}. Luego, para cada implementación de objeto activo existe una máquina de estados asociada en un archivo de encabezados (.h),  y un archivo ejecutable (.c) con el prefijo \textit{statemachine}. Finalmente, los archivos con el prefijo \textit{ISR} corresponden a las rutinas de interrupción. Como cada máquina de estado utiliza recursos del sistema operativo, se ha creado un archivo \textit{common.h} que declara aquellos recursos como colas, \textit{handlers} y semáforos que se utilizan entre tareas para comunicación interprocesos.\\

Esta organización permite encapsulamiento y la modularidad de los componentes del sistema, lo que facilita la escalabilidad y el mantenimiento del sistema.\\

\subsection{Uso de recursos en RTOS}

En este desarrollo, se utiliza freeRTOS, una versión en C de un \textit{kernel} de sistema operativo de tiempo real. La implementación se basa en la inclusión de los archivos de cabecera \textit{FreeRTOS.h} y \textit{FreeRTOSConfig.h}. Esta implementación ha sido validada en arquitecturas ARM Cortex-M4, específicamente en la plataforma EDU-CIAA. 

En todos los casos que fue posible, se utilizaron semáforos, colas y \textit{mutex} para organizar y proteger el uso compartido de recursos. El caso de uso típico de \textit{mutex} es la interacción de distintas tareas con la misma interfaz UART-USB para imprimir mensajes por pantalla. En el código fuente de cada objeto implementado, se utiliza la siguiente plantilla para proteger el recurso, evitando accesos múltiples y posibilidad de \textit{deadlock}:\\

\begin{lstlisting}[caption=Ejemplo de protección de recursos compartidos.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
if (pdTRUE == xSemaphoreTake( xMutexUART, portMAX_DELAY)){
   vPrintString("Task AB is running.\r\n");
   xSemaphoreGive(xMutexUART);
}
\end{lstlisting}

Las colas, conocidas como \textit{Queue}, se utilizan principalmente para comunicar eventos entre objetos activos. En todos los casos se referencian con \textit{handlers} usando el prefijo \textit{queueHandle} como nomenclatura. En el siguiente fragmento de código se muestra un ejemplo, exibiendo los mecanismos de control de errores utilizados. \\

\begin{lstlisting}[caption=Ejemplo de creación de cola.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
queueHandle_button = xQueueCreate(QUEUE_MAX_LENGTH, sizeof(eSystemEvent_button));
if (queueHandle_button == NULL){
    perror("Error creating queue");
    return 1;
}
\end{lstlisting}


Todas las tareas y recursos del sistema operativo se han protegido contra errores informando al usuario ante fallas en la instanciación, previas al inicio del \textit{scheduler} u orquestador.

\begin{lstlisting}[caption=Ejemplo de protección en la creación de tarea al inicio del orquestador.,
	language=C, 
	backgroundcolor=\color{mygray}
	]
if( xTaskCreate( vTaskReadSerial, "Serial Comm reading task", 
    configMINIMAL_STACK_SIZE*4, NULL, tskIDLE_PRIORITY+2, &xTaskReadSerialHandler) 
    == pdFAIL ) {
    perror("Error creating task");
}
\end{lstlisting}

Se utilizan también punteros de tipo \textit{xTaskHandle} para referenciar las tareas del sistema operativo. Este tipo de referencias son de especial utilidad a la hora de eliminar tareas de forma dinámica en tiempo de ejecución, y también se pueden utilizar para la comunicación entre tareas.\\

El uso de \textit{timers} por software fue el preferido en aquellos casos que su uso facilita el mantenimiento, legibilidad y comprensión de la implementación. La plantilla desarrollada para la creación de \textit{timers} se presenta en el siguiente fragmento de código.

\begin{lstlisting}[caption=Ejemplo de creación de temporizadores por software.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
void timerCallback_displayled(TimerHandle_t xTimerDisplayHandle){

   if (pdTRUE == xSemaphoreTake( xMutexUART, portMAX_DELAY)){
      printf("Timer display led is running.\r\n");
      xSemaphoreGive(xMutexUART);
   }

   eSystemEvent_displayled  displayled_timer_event = evDisplayled_timeout;
   
   if(xQueueSend(queueHandle_displayled, &displayled_timer_event, 0U)!=pdPASS){
         perror("Error sending data to the queueHandle_displayled\r\n");
   }
}

\end{lstlisting}

Se procuró tener especial cuidado de superposición o competición del reloj del sistema operativo entre tareas. Distintos componentes pueden tener requisitos temporales que compiten por la prioridad del orquestador. Para ilustrar este aspecto, se detallará la implementación del display led como un ejemplo que puede competir con el arribo de mensajes por la interfaz UART.\\

Las rutinas de interrupción por hardware, conocidas como \textit{ISR}, se utilizan cuando se requiere respuesta inmediata. Por ejemplo, al accionar manualmente un interruptor o bien al recibir mensajes o señales eléctricas desde el bus de datos del tren. La implementación elegida para el uso de interrupciones se representa en el diagrama de secuencia de la figura \ref{fig:ISR}. \\

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/ISRcallback.png}
	\caption{Diagrama de secuencia que representa la interacción entre componentes del sistema operativo cuando se dispara una interrupción o ISR.}
	\label{fig:ISR}
\end{figure}

El recurso de hardware que genera interrupciones (ISR) llama a una función \textit{callback} (\textit{ISR callback}), que sólo se encarga de entregar un mensaje de evento al sistema. Esta función no tiene lógica implementada, sólo avisa al sistema que hay una interrupción que atender. El evento se comunica a través de una cola, recurso elegido como interfaz de mensajes de los objetos activos. La cola es atendida por una tarea de sistema (\textit{vTask}) que resuelve el código de ejecución. Esta tarea normalmente implementa un objeto activo que actualiza una máquina de estado.\\

Aunque la complejidad del mecanismo de atención de interrupciones puede resultar llamativa, este patrón basado en objeto activo permite desacoplar la invocación y la ejecución de una máquina de estados. El objeto activo es una técnica de concurrencia muy utilizada debido a su capacidad para separar en hilos independientes (\textit{threads}) la invocación de funciones (eventos) de las funciones de ejecución. Con este mecanismo aparece la posibilidad de atender múltiples eventos en simultáneo, sin esperar a que se procese cada evento secuencialmente. Esto permite lograr paralelismo, garantizar la atomicidad en la función que atiende la interrupción, mantener una latencia muy baja y asegurar la consistencia con en el uso de objetos activos bajo los lineamientos de la arquitectura orientada a eventos.\\


Por último, se menciona el uso de memoria dinámica. El sistema cuenta con una interfaz de comunicación UART que, en principio, recibirá mensajes de longitud variable y desconocida. Por lo tanto, se optó por utilizar \textit{buffers} dinámicos para el almacenamiento y procesamiento de datos. Para el manejo de memoria dinámica se hace uso de funciones como \textit{memset()}, \textit{pvPortMalloc()}, \textit{memcpy()} y \textit{vPortFree()}, a través de dos instancias de ejecución: una para la recepción y el almacenamiento de datos, y otra para la ejecución y liberación de memoria. En el siguiente fragmento de código se detalla el uso de estas funciones en el contexto de dos tareas: \textit{reader} y \textit{writer}.


\begin{lstlisting}[caption=Ejemplo de memoria dinámica con dos tareas reader y writer.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
void vTaskReader(void *parameters) {
   // Clear whole buffer
   memset(buf, 0, buf_len);
   // Loop forever
   while (true) {
   // Read from UART
      uint8_t c_data=0;
      if (uartReadByte( UART_USB, &c_data ) == true ){
      // Store to buffer if not over buffer limit  
         if (idx < buf_len - 1){
            buf[idx] = c_data;
            idx++;
         }
         // Create a message ending string with null
         if (c_data == '\n') {
            buf[idx - 1] = '\0';
            // Allocate memory and copy message. 
            if (msg_flag == 0) {
               msg_ptr = (char *)pvPortMalloc(idx * sizeof(char));
               if (msg_ptr==NULL){
                  if (pdTRUE == xSemaphoreTake( xMutexUART, portMAX_DELAY)){
                     printf("Buffer out of memory\r\n");
                     xSemaphoreGive(xMutexUART);
                  }
               }
               // Copy message
               memcpy(msg_ptr, buf, idx);
               // Notify other task that message is ready
               msg_flag = 1;
            }
            // Reset buffer and index
            memset(buf, 0, buf_len);
            idx = 0;
         }
      }
   }
}     

void vTaskWriter(void *parameters) {
   if (uart_msg_flag == true) {
      // Print the message in the buffer 
      if (pdTRUE == xSemaphoreTake( xMutexUART, portMAX_DELAY)){
        printf("%s\r\n", uart_msg_ptr);
        xSemaphoreGive(xMutexUART);
      }
      // Free the memory block  
      vPortFree(uart_msg_ptr);  
      uart_msg_ptr  = NULL;
   }
}

\end{lstlisting}

Como se puede observar, cuando se recibe un carácter por la interfaz UART, se copia este carácter en el \textit{buffer}, siempre y cuando haya espacio disponible. Una vez que el \textit{buffer} se llena, se solicita memoria adicional y se copia el mensaje utilizando un puntero al bloque de memoria asignado. Luego, la tarea de ejecución lee el mensaje de ese puntero a memoria, o bien lo procesa para invocar otra función.\\


\subsection{Patrones de software}
En este desarrollo se ha hecho uso extensivo de los patrones máquina de estado, objeto activo, \textit{pipeline}, observar y reaccionar, y superciclo. Se presenta en detalle el formato de plantillas desarrollado en C para freeRTOS para los patrones de máquinas de estado y de objeto activo. \\

\subsubsection{Máquinas de estado}
La arquitectura orientada a eventos propuesta se desarrolla a través de la interacción de máquinas de estado mediante el uso de objetos activos. En este trabajo, la implementación de las máquinas de estado se lleva a cabo de manera sistemática en el lenguaje C, siguiendo un procedimiento paso a paso que se describe a continuación. Como ejemplo, se utiliza una máquina de dos estados A y B, que cambia de un estado a otro en respuesta a un evento temporal (\textit{evTimeout}):

\begin{enumerate}
\item Representación de los estados y eventos con diagrama de estados.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/statemachineAB.png}
	\caption{Diagrama de la máquina de estados AB ejemplo.}
	\label{fig:fsmAB}
\end{figure}

\item Definición de los estados, usando tipo enumerativo definido con el prefijo \textit{eSystemState}:

\begin{lstlisting}[caption=Definición de estados.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef enum{
    
    STATE_INIT,
	STATE_A,
	STATE_B

} eSystemState;
\end{lstlisting}

\item Definición de los eventos. Los eventos representan transiciones entre estados con un tipo enumerativo definido con el prefijo \textit{eSystemEvent}:

\begin{lstlisting}[caption=Definición de eventos.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef enum{

	evInit,
	evTimeout

} eSystemEvent;
\end{lstlisting}

\item Definición de un tipo puntero a función usando el prefijo \textit{*pfEventHandler()} para designar los handlers específicos:

\begin{lstlisting}[caption=Definición de puntero a handlers.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef eSystemState (*pfEventHandler)(void);
\end{lstlisting}

\item Definición de una estructura para la máquina de estados definiendo un tipo \textit{sStateMachine}. Esta estructura debe incluir una variable estado (\textit{eSystemState}), una variable evento (\textit{eSystemEvent}) y un puntero a función (\textit{pfEventHandler}). El puntero a función será una instancia de \textit{handler} específico que maneje las transiciones entre estados. 

\begin{lstlisting}[caption=Estructura para máquina de estados.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef struct{

	eSystemState  	fsmState;
	eSystemEvent  	fsmEvent;
	pfEventHandler	fsmHandler;

} sStateMachine;
\end{lstlisting}

\item Definición de los \textit{handlers} a implementar para el manejo de ejecución y transiciones entre estados.

\begin{lstlisting}[caption=Definición de handlers.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
eSystemState 	InitHandler(void);
eSystemState 	AHandler(void);
eSystemState 	BHandler(void);
\end{lstlisting}

\item Instanciación de la máquina de estados como un arreglo de estructuras usando el prefijo \textit{sStateMachine\_}. Para el ejemplo de la máquina AB, la instancia de arreglo de estructuras sería la siguiente:

\begin{lstlisting}[caption=Ejemplo de instanciación de una máquina de estados.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
sStateMachine_AB fsmMachineAB [] = 
{
	{STATE_INIT_AB, evInit_AB, InitHandler_AB},
	{STATE_A, evTimeout, AHandler},
	{STATE_B, evTimeout, BHandler}
};
\end{lstlisting}

En esta definición habrá un \textit{handler} en el momento de inicialización (\textit{initHandler}) y  un \textit{handler} específico para cada estado.

\item Escribir el código ejecutable de los \textit{handlers}. Una implementación a modo de ejemplo se presenta en el siguiente fragmento de código:

\begin{lstlisting}[caption=Ejemplo de implementación de handlers.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
eSystemState 	InitHandler(void){ 
	printf("State Machine Init...\n");
	return STATE_A; 
}

eSystemState 	AHandler(void){ 
	printf("State Machine State A\n");
	return STATE_B; 
}

eSystemState 	BHandler(void){ 
	printf("State Machine State B\n");
	return STATE_A; 
}
\end{lstlisting}
\end{enumerate}


Se debe notar que para este ejemplo cada transición de estados se ejecutará por el evento \textit{evTimeout}. La máquina inicia y se define en el estado STATE\_A y luego alterna entre \textit{STATE\_A} y \textit{STATE\_B} por cada evento de timeout.

De esta manera, queda desacoplada la implentación de los \textit{handlers} del resto de la estructura de la máquina de estados, logrando portabilidad, escala y modularidad. Los \textit{handlers} serán funciones que se implementan con el sufijo \textit{Handler()} y que por definición tienen un solo argumento de tipo \textit{void}.

Con esta técnica de desacoplamiento, se implementan dos archivos por cada máquina de estado : uno de encabezados (\textit{stateMachine.h}) con las definiciones, y otro con la implementación (\textit{stateMachine.c}) de los handlers.




\subsubsection{Objeto activo}
	
Los objetos activos se implementan en esta aplicación como tareas de freeRTOS, usando dos superciclos anidados de tipo \textit{while(true)}, tal como se muestra en el siguiente fragmento de código: 

\begin{lstlisting}[caption=Plantilla de implementación para objetos activos.,
	language=C, 
	backgroundcolor=\color{mygray},
	]
void vTaskAB(void *xTimerHandle)
{
   (void)xTimerHandle;

   // Task successful creation message
   if (pdTRUE == xSemaphoreTake( xMutexUART, portMAX_DELAY)){
      printf("Task AB is running.\r\n");
      xSemaphoreGive(xMutexUART);
   }

   while(true){
      
      // State machine init
      eSystemEvent_AB newEvent	=	evInit_AB;
      eSystemState_AB nextState	=	STATE_INIT_AB;
      fsmMachineAB[nextState].fsmEvent = newEvent; 
      nextState = (*fsmMachineAB[nextState].fsmHandler)();

      // Active object
      while(true){
        if( pdPASS == xQueueReceive(queueHandle_AB, &newEvent, portMAX_DELAY)){
            fsmMachineAB[nextState].fsmEvent = newEvent; 
            nextState = (*fsmMachineAB[nextState].fsmHandler)();
         }
      }
   }
}
\end{lstlisting}

Es importante notar que el primer ciclo \textit{while()} es el que corresponde al funcionamiento normal de una tarea o proceso de RTOS. En este caso, es el encargado de inicializar la máquina de estados asociada al objeto activo. El ciclo \textit{while()} de la línea 20 se encarga de bloquear la tarea hasta que se reciba un evento por la interfaz (cola de eventos). La interfaz del objeto activo es una cola FIFO (\textit{First In First Out}) con la función de sistema \textit{xQueueReceive() }(línea 21). Si se recibe un evento, entonces se actualiza el estado de la máquina instanciando el handler que corresponda, como se observa en la línea 25. El diagrama de la figura \ref{fig:AOfsmAB} representa el objeto activo detallado. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.85\textwidth]{./Figures/AOstatemachineAB.png}
	\caption{Diagrama del objeto activo de la máquina de estados AB ejemplo.}
	\label{fig:AOfsmAB}
\end{figure}

Para este ejemplo, la tarea de sistema recibe una referencia a un timer (\textit{xTimerHandle}) que genera eventos de \textit{timeout} y los encola en la interfaz del objeto activo (\textit{Queue}). Con la misma interfaz, los eventos también podrían ser generados por otros objetos activos, o por rutinas de interrupción. Los mensajes en cola los recibe  la tarea de sistema que actualiza la máquina de estados (\textit{vTaskAB}).\\

\subsection{Componentes del sistema}

En esta sección, se describen los componentes principales de la solución representada con el diagrama estructural de la figura \ref{fig:diagVistaDisenho}. En la figura \ref{fig:diagramaSecuenciaSistema} se presentan las interacciones entre componentes en forma de secuencia para los distintos casos de uso. Los cuatro objetos activos utilizados son:\\
\begin{itemize}
\item \textbf{UART}: objeto activo que sirve de interfaz de comunicación con la red RS485 del sistema PIDS. Se encarga de recibir los mensajes de la red, identificarlos y enviarlos al objeto PIDS.
\item \textbf{PIDS}: objeto activo que contiene la lógica de procesamiento de señales del tren, los mensajes que se visualizan en pantalla y los trayectos disponibles. 
\item \textbf{displayled}: objeto activo responsable de codificar los mensajes que vienen del PIDS para ser visualizados en un display de matriz led.
\item \textbf{Button}: objeto activo responsable de recibir accionamientos manuales del conductor del tren.
\end{itemize}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{../Figures/secuenciasSistema.png}
	\caption{(a) Caso de uso de visualización de estación; (b) Caso de uso de receptor de tramas; (c) Caso de uso de elección de destino por accionamiento del conductor; (d) Caso de uso de visualización de información de asistencia.}
	\label{fig:diagramaSecuenciaSistema}
\end{figure}


%La organización del orquestador del sistema operativo se representa con el diagrama temporal de la figura \ref{fig:diagramasTemporales}. La base de este diagrama es el orden de prioridades de las tareas de objetos activos, los timers y los handlers de interrupciones que manejan los periféricos de hardware.\\

\subsubsection{Periférico UART}

 Este tipo de interfaz suele ser común en numerosas aplicaciones y abundan ejemplos utilizados para leer y escribir desde y hacia un periférico UART. El caso trivial es una aplicación 'eco': todo lo que se recibe por la UART se vuelve a escribir y enviar por la UART. Sin embargo, la aplicación específica determina la lógica de procesamiento de mensajes. Por ejemplo, si se recibe un caracter determinado, entonces se activa tal objeto; si se genera un evento en tal otro objeto, entonces se envía un mensaje de aviso. \\

En el sistema desarrollado, la UART es la interfaz de comunicación con el resto de la red PIDS. Esta debe procesar eventos que indican aceleración y desaceleración del tren. Como se verá en la sección de ensayos, se ha observado que las tramas normalmente tienen un encabezado (\textit{header}), una carga de datos (\textit{payload}), y un final de trama (\textit{trailer}). En los ensayos también se ha observado que los mensajes transmitidos en la red PIDS de los trenes de SOFSE pueden tener largo variable. El diseño de este componente se representa con el diagrama de la figura \ref{fig:diagfsmUART}.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/fsmUART3.png}
	\caption{Diagrama del objeto activo UART implementado.}
	\label{fig:diagfsmUART}
\end{figure}

El periférico UART es un componente de bajo nivel del microcontrolador que admite el control por interrupciones (ISR). Cada byte entrante genera una interrupción y de inmediato el \textit{handler} \textit{IRQ\_UART} envía un mensaje de actualización al objeto activo. Los eventos admitidos son:
\begin{itemize}
\item \textit{evUart\_Received\_byte} para la recepción de un byte de datos; 
\item \textit{evUart\_Timeout}, generado por un timer específico de control.\\
\end{itemize} 

La máquina de estados admite cuatro estados distintos:
\begin{itemize}
\item \textit{IDLE}: estado inicial y de reposo.
\item \textit{LISTENING}: estado generado al recibir el Header o inicio de trama.
\item \textit{VALID}: estado generado al completar un mensaje con el Trailer o final de trama.
\item \textit{ERROR}: estado alcanzado una vez generado un timeout en el estado listening.
\end{itemize}

El estado \textit{LISTENING} es el \textit{core} de la máquina de estados. El \textit{handler} de ejecución permite almacenar en memoria dinámica el contenido de un mensaje de longitud variable una vez que se recibe un byte de inicio de trama.  El mensaje se completa cuando se recibe un byte de final de trama, que genera mediante \textit{timeout} el evento de transición al estado \textit{Valid}. La lógica detrás de este diseño es que, una vez que se valida una trama de datos, se genera un evento de actualización hacia el componente externo PIDS. De esta manera, se desarrolló un componente UART con flexibilidad, que permite cambiar los bytes de \textit{header} y \textit{trailer} y admite un \textit{buffer} de longitud variable usando memoria dinámica. \\

\subsubsection{Display led}

En esta sección se describe la solución implementada para controlar carteles de matriz led. La estructura de control, el conjunto de chips compatibles, el uso y posible reutilización en otros sistemas se presenta con diagramas y detalles de código fuente. \\

Los carteles led utilizados en este trabajo se basan en una tecnología de microcontrolador (MCU) y sistema digital. El MCU genera los mensajes a visualizar en formato de datos binarios, y el sistema digital recibe los datos binarios y señales de control para prender los leds del cartel de forma ordenada. Los carteles se componen de módulos matriciales de 8x8 leds, es decir, 8 filas de 8 leds por fila cada módulo. Los arreglos de módulos forman paneles, y los arreglos de paneles forman carteles. Los módulos  pueden ser controlados a través de pulsos de tensión sincronizados entre filas y columnas. Sin embargo, si se quisiera controlar varios módulos de matriz led en simultáneo, la cantidad de señales a priori podría ser proporcional al número total de leds. El sistema digital expone una solución para que los paneles, como arreglos de módulos, puedan ser direccionados por un grupo de tres o cuatro señales de control usando técnicas de multiplexación y registros de desplazamiento, o \textit{Shift Registers}, como se describe a continuación. \\


\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/diagDriverled.png}
	\caption{Diagrama de bloques del controlador de los carteles de matriz led utilizados en esta implementación.}
	\label{fig:diagDriverled}
\end{figure}

En la figura \ref{fig:diagDriverled} se presenta un diagrama de bloques del sistema digital de control para carteles de matriz led basados en el \textit{chipset} 74HC245, 74HC595 y 74HC138. Se pueden distinguir los siguientes bloques:

\begin{itemize}
\item \textit{MCU}: se encarga de generar y transmitir las señales del sistema a través del conector de entrada del cartel de matriz led.
\item \textit{input connector}: conector de pines en el cartel para señales de entrada (\textit{Data, Clock, Latch}) provenientes del MCU.
\item \textit{output connector}: conector de pines en el cartel para señales de salida, para interconexión en serie con otro cartel.
\item \textit{Buffer}: adaptador de nivel de la señal de tensión y derivador a izquierda o derecha de la placa física.
\item \textit{Shift Registers}: registros de desplazamiento para enviar datos binarios a las columnas de los paneles.
\item \textit{Deco}: doble decodificador 3x8 para habilitar secuencialmente las filas de los paneles.
\item \textit{MOSFET Array}: circuito de corriente para energizar las filas de los paneles.
\item \textit{Led dot matrix array}: el cartel de matriz led propiamente dicho.
\end{itemize}

El funcionamiento del circuito es el siguiente. Los mensajes y señales de control (\textit{data}, \textit{clock}, \textit{latch}, \textit{deco}) se generan en el MCU y se transmiten al cartel a través de un conector de entrada (\textit{input connector}). Las señales de control se direccionan a izquierda y derecha a través de \textit{buffers} de la serie 74HC245D, que además entregan un nivel lógico de salida consistente, por ejemplo de 5 Volt. Las señales que van para el lado izquierdo contienen los datos binarios a visualizar en el cartel. A través de los registros de desplazamiento, los datos binarios (\textit{data}) se cargan bit a bit sincronizados con cada ciclo de reloj (\textit{clock}), hasta cargar los leds de una fila completa del cartel. Luego se envía un pulso de \textit{latch} para descargar la fila y habilitar los registros de desplazamiento para los datos de la siguiente fila. Por el lado derecho del \textit{buffer},  un par de decodificadores 74HC138 permiten encender hasta 16 salidas secuencialmente. En cada ejecución de la señal \textit{deco} se energiza una fila usando transistores (\textit{MOSFET Array}), que entregan la corriente necesaria para que todos los leds de cada fila puedan brillar con intensidad. La secuencia coordinada de enviar los datos a una fila, energizarla y luego hacer lo mismo con la fila siguiente, se repite hasta completar todas las filas del cartel en ciclos de 20 ms. De esta manera, se transmite un mensaje completo al cartel aproximadamente 50 veces por segundo, formando una imagen continua vista por el ojo humano.\\

 Para armar carteles más grandes, ses común conectar el conector de salida de un cartel al conector de entrada de otro idéntico, logrando conexiones en serie entre paneles. La lógica de codificación de mensajes es la misma, logrando que un solo panel se conecte al MCU y el resto siga una conexión en cascada, usando el mismo grupo de señales generadas.\\
 
 
Los datos que se generan en el MCU para visualizar mensajes responden a un procesamiento ordenado de información. En la implementación desarrollada, se debe transformar el mensaje a visualizar como texto plano, y luego codificarlo en una matriz de unos y ceros que tenga las dimensiones del cartel de matriz led. A modo de ejemplo, si se codificara un caracter por módulo, se podría enviar mensajes de hasta 16 caracteres con un arreglo de 16 módulos 8x8. Cada carácter requiere de un mapa de bits que permita asociarlo con una matriz de datos binarios de 8x8. En la figura \ref{fig:dataPipeline} se muestra un ejemplo con la letra 'H' codificada por la función f1, y se presenta esquemáticamente la implementación desarrollada. Se han diseñado dos funciones f1 y f2 usando el patrón \textit{pipeline} (f1 y f2) para preprocesar mensajes de texto en datos binarios compatibles con el formato de carteles de matriz led. La función f1 se llama \textit{"string\_read\_to\_8x8\_bytes\_out()"}, se encarga de recibir un mensaje en texto plano, mapearlo a un diccionario de caracteres y matrices, y entregar un arreglo de números que corresponden al mapa binario de 8x8 de cada caracter. Así, por cada caracter que recibe f1 se generan 8 números binarios. Luego, la función f2 llamada \textit{"reshape\_to\_display()"} recibe como argumentos las dimensiones del cartel y reordena el arreglo de números binarios acorde al formato del cartel. Esta última función es esencialmente una operación de transposición de matriz y considera tres casos posibles: si el mensaje a visualizar es más corto que el espacio del cartel, si es más largo, o si tiene la misma longitud. En cada caso, la función ajusta la matriz transpuesta, llenando con ceros cuando es necesario.\\

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/dataPipeline.png}
	\caption{Procesamiento de datos para codificar mensajes.}
	\label{fig:dataPipeline}
\end{figure}

La pieza de software desarrollada para el control del display led es un objeto activo consistente con el resto del sistema. El diagrama de la máquina de estados asociada se presenta en la figura \ref{fig:fsmDisplayled}. Se pueden distinguir tres estados, cada uno con un handler asociado. El estado \textit{IDLE} es el estado inicial del sistema y es también el estado de reposo cuando no hay información para visualizar en el cartel. Ante un evento de mensaje recibido (\textit{evDisplayLed\_msg\_received}), hay una transición al estado \textit{PROCESSING} y se ejecuta el \textit{pipeline} descrito para transformar texto plano en matrices de unos y ceros. Finalizado el procesamiento, se entrega al sistema digital para energizar el cartel y visualizar la información dentro del estado \textit{ENCODING}.\\

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/FSMdisplayled.png}
	\caption{Diagrama de estados para la máquina de estados del display led.}
	\label{fig:fsmDisplayled}
\end{figure}

En los siguientes fragmentos de código se detallan los \textit{handlers} desarrollados para la máquina de estados presentada. El handler \textit{displayled\_procHandler()} implementa el pipeline de las funciones f1 y f2. Se puede observar que luego del mapeo de caracteres a arreglos de bytes en la línea 9, el reordenamiento de los bytes implica pasar de una matriz de dimensiones nxm, con 'n' la cantidad de filas por caracter y 'm' el largo del mensaje, a una matriz pxq, con 'p' la cantidad de filas del display led y 'q' la cantidad de columnas. El ciclo de la línea 19 inicializa en cero la nueva matriz y en la línea 22 se completa el pipeline con la función f2.\\

\begin{lstlisting}[caption=Handler para procesamiento de datos de cartel de matriz led.,
	language=C, 
	backgroundcolor=\color{mygray},
	caption=	{Código fuente del handler de procesamiento del display led.},
	captionpos=b]
eSystemState_displayled     displayled_procHandler(void){

    char *str1=messages[displayled_msg_idx];

    uint8_t str1_len=strlen(str1);
    uint8_t buffer_size=str1_len*CHAR_LENGTH;
    uint8_t buffer[buffer_size];

    string_read_to_8x8_bytes_out(str1,str1_len,buffer);

    int n=CHAR_LENGTH; 
    int m=str1_len;
    int p=DISPLAYLED_ROWS;
    int q=DISPLAYLED_COLS;

    int displayled_size = p*q;

    uint8_t B[displayled_size];
    for(int i=0; i<displayled_size;i++)
    B[i]=0;

    reshape_to_display(buffer, displayled_buffer, buffer_size, displayled_size);

    displayled_msg_idx++;
    displayled_msg_idx%=MESSAGES_TOTAL_NUMBER;
    displayled_msg_flag=0;

    return STATE_DISPLAYLED_ENCODING;
}

\end{lstlisting}

El \textit{handler} \textit{diplayLed\_dataHandler()} implementa la lógica del sistema digital asociado al cartel, detallado al principio. Se pueden observar dos ciclos for anidados en las líneas 12 y 16, uno para recorrer caracter a caracter el mensaje, y otro para escanear bit a bit cada caracter. La línea 19 implementa una máscara de bit a bit para transmitir el dato al registro de desplazamiento, y las líneas 33-34 generan el pulso de \textit{latch}. La secuencia codificada de las líneas 36 en adelante implementan la habilitación fila a fila usando decodificadores 3 a 8. \\

\begin{lstlisting}[caption=Handler para codificación de datos en cartel de matriz led.,
	language=C, 
	backgroundcolor=\color{mygray},
	caption=	{Código fuente del handler de encoding del display led.},
	captionpos=b]
eSystemState_displayled     displayled_dataHandler(void){

    uint8_t data_8b;
    bool_t  value;

    displayled_timer_cnt--;
    if(!displayled_timer_cnt){
        displayled_msg_flag=0;
        return STATE_DISPLAYLED_IDLE;
    };    

    for(int i=0; i<displayled_size; i++){
        data_8b = displayled_buffer[i];
        for(int j=0; j<8; j++){
            // displayled_data 
            value = (((data_8b << j ) & 0x80 ) == 0) ? 1 : 0;
            printf("%d",value);
            gpioWrite(displayled_panel_1, value);
            gpioWrite(displayled_panel_2, value);
            // displayled_clock 
            gpioWrite(displayled_clk, ON);
            gpioWrite(displayled_clk, OFF);
        }
        
        if(i%DISPLAYLED_COLS==0){
            // displayled_latch 
            gpioWrite(displayled_latch, ON);
            gpioWrite(displayled_latch, OFF);
            // displayled_row_scanning
            displayled_deco_cnt++;
            displayled_deco_cnt%=DISPLAYLED_ROWS;
            if((displayled_deco_cnt%1)==0){ 
            		gpioToggle(displayled_deco_A0); }
            if((displayled_deco_cnt%2)==0){ 
            		gpioToggle(displayled_deco_A1); }
            if((displayled_deco_cnt%4)==0){ 
            		gpioToggle(displayled_deco_A2); }
            if((displayled_deco_cnt%8)==0){ 
            		gpioToggle(displayled_deco_A3); }
        }
    }
    
    return STATE_DISPLAYLED_ENCODING;
}

\end{lstlisting}

Con esta implementación de controlador de matriz led, ha sido posible realizar distintas pruebas de funcionamiento que se detallan en el capítulo siguiente.\\
