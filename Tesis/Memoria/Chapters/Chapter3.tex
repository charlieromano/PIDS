\chapter{Desarrollo} % Main chapter title

En este capítulo se presentan los requerimientos del sistema y la solución propuesta. En el desarrollo se utiliza la plataforma de hardware EDU-CIAA\cite{CIAA}, la API Firmware\_ v3\cite{firmwareV3}, y freeRTOS\cite{freeRTOS} como sistema operativo de tiempo real.\\

Se presenta el desarrollo siguiendo lineamientos de ingeniería de software en el siguiente orden: requerimientos, funcionalidades y casos de uso principales como ejes del espacio problema; arquitectura, patrones de software involucrados, técnicas de concurrencia, diagramas de secuencia, de interacción entre componentes, organización del firmware y planos de hardware para describir el espacio solución.\\


\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.95,0.95,0.95}
\definecolor{mygray50}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parámetros para configurar el formato del código en los entornos lstlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{ %
  backgroundcolor=\color{mygray},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,                % the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray50}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}
}
\lstdefinestyle{nonumbers}
{numbers=none}
  


\section{Requerimientos}

 El objetivo principal de este trabajo es diseñar e implementar un sistema de información visual para pasajeros a bordo del tren. Está dirigido a:
\begin{enumerate}
\item Todos los  miembros del grupo de trabajo GICSAFE y SOFSE que participan de proyectos orientados a cubrir necesidades tecnológicas del sistema ferroviario argentino.
\item Alumnos y personal académico con intenciones de participar en proyectos de desarrollo aplicados a la industria.
\item Desarrolladores de software y equipamiento para trenes.
\end{enumerate}

A nivel general, los requerimientos del proyecto son los siguientes:

\begin{itemize}

\item El sistema debe leer datos de información al pasajero de la red interna de los trenes y presentarlos en un display LED. El sistema no se encargará de presentar los mensajes en formato de audio.

\item Este sistema permitirá implementar las funciones de visualización del sistema de información al pasajero existente. El sistema comercial existente es un equipamiento propietario que integra otras funciones como el sistema de audio, un CCTV usando cámaras de seguridad, entre otras. 

\item El sistema que se especifica busca desacoplar funciones del equipamiento comercial para permitir reponer carteles que en la actualidad quedan fuera de servicio por fallas o pérdida del material original y que no pueden ser reparados. 

\end{itemize}

Estos requerimientos generales se traducen en requerimientos específicos y se dividen en tres grupos que se detallan a continuación: requerimientos funcionales, de integración y de documentación. 

\textbf{Requerimientos funcionales
}\begin{itemize}
\item El sistema debe controlar arreglos de matrices LED de 8x8 (64 LED individuales).
\item El sistema debe presentar en el display información dinámicamente.
\item El sistema debe poder almacenar una cantidad de información para visualización.
\item El sistema debe permitir elegir entre distintos mensajes de visualización.
\item El sistema debe permitir cargar los mensajes a visualizar a través de una computadora.
\item El sistema debe poder reaccionar a un mensaje que es enviado para visualizar.
\end{itemize}

\textbf{Requerimientos de integración con la red TCN
}\begin{itemize}
\item Las placas de control deben ser compatibles con el sistema PIDS existente.
\item Las placas de control deben poder alimentarse con 110 VDC.
\item El bus de datos de entrada debe ser una interfaz RS-485.
\item El sistema debe interpretar las tramas del PIDS que corresponden a los módulos LDU.
\item El sistema debe manejar tramas en ciclos típicos de 16-20 ms.
\end{itemize}

\textbf{Requerimientos de documentación
}\begin{itemize}
\item Se debe generar un documento de casos de prueba.
\item Se debe generar una guía de usuario.
\item Se debe generar una presentación del sistema.
\item Se debe generar un informe final de proyecto.
\end{itemize}

La tabla \ref{tab:Reqs} sintetiza los requerimientos y les asigna un código de referencia para la evaluación de su cumplimiento.
	
\begin{table}[htb]
\begin{tabular}{|l|l|}
\hline
\textbf{Código} & \textbf{Descripción}                                 \\ \hline
PIDS-REQ-FN-01  & Control de módulos de matriz led 8x8                 \\ \hline
PIDS-REQ-FN-02  & Control de paneles de 2x6 modulos                    \\ \hline
PIDS-REQ-FN-03  & Control de displays basados en arreglos de 3 paneles \\ \hline
PIDS-REQ-FN-04  & Visualización de mensajes en idioma castellano       \\ \hline
PIDS-REQ-FN-05  & Visualización de mensajes dinámicos                  \\ \hline
PIDS-REQ-FN-06  & Almacenamiento de información de trayecto            \\ \hline
PIDS-REQ-FN-07  & Selección de contenidos disponibles                  \\ \hline
PIDS-REQ-FN-08  & Upstream de mensajes desde una computadora personal  \\ \hline
PIDS-REQ-INT-01 & Compatibilidad de sistema con sistema existente      \\ \hline
PIDS-REQ-INT-02 & Compatibilidad eléctrica                             \\ \hline
PIDS-REQ-INT-03 & Compatibilidad de interfaces RS485                   \\ \hline
PIDS-REQ-INT-04 & Compatibilidad con tramas de datos del módulo LDU    \\ \hline
PIDS-REQ-INT-05 & Procesamiento de tramas menor a 16 ms                \\ \hline
PIDS-REQ-DOC-01 & Documentación de casos de prueba                     \\ \hline
PIDS-REQ-DOC-02 & Guía de usuario                                      \\ \hline
PIDS-REQ-DOC-03 & Presentación del sistema                             \\ \hline
PIDS-REQ-DOC-04 & Informe final de proyecto                            \\ \hline
\end{tabular}
	\caption{Tabla de requerimientos funcionales, de integración y de documentación del proyecto.}
	\label{tab:Reqs}
\end{table}


Por último se explicita que para el desarrollo del presente proyecto se asume que:

\begin{itemize}
\item No habrá dependencias directas con otros proyectos enmarcados en el mismo PDE\cite{PDE-TCN}.
\item No habrá dificultad ni excesivas demoras en la compra de los componentes electrónicos o
de software necesarios.
\item Se contará con recursos y materiales necesarios para validar las pruebas realizadas.
Trenes Argentinos dará acceso a una formación ferroviaria con red TCN para realizar
pruebas de campo.
\item El Sistema de Información al Pasajero se va a instalar en el sistema PIDS existente de
las formaciones ferroviarias en operación.
\item El sistema de información al pasajero no se va a instalar en redes TCN de tiempo real
basadas en Ethernet (ETB/ECN).
\end{itemize}


\section{Casos de Uso}
Los casos de uso planteados se presentan como respuesta a historias de usuario. Las historias de usuario principales propuestas en este trabajo son:
\begin{itemize}
\item Como usuario del tren quiero ver el nombre de la estación a la que estoy arribando.
\item Como conductor del tren quiero elegir el destino y recorrido asociado que se visualizará en los coches.
\item Como sistema vinculado quiero transmitir mensajes de asistencia, emergencia e información al pasajero.
\item Como componente de sistema quiero recibir e interpretar tramas de la red de datos del sistema PIDS
\end{itemize}

Estas historias de usuario presentan cuatro tipos distintos de usuarios: pasajeros, conductores, sistemas de información al pasajero, y componentes internos del sistema. Con esta oferta de usuarios de sistema se busca definir funcionalidad y casos de uso. Los principales casos de uso del sistema se presentan en la tabla \ref{tab:UseCases}. \\

\begin{center}
\begin{table}[htb]
\begin{tabular}{|l|l|}
\hline
\textbf{Código} & \textbf{Descripción}     \\ \hline
PIDS-UC-01  & Visualizar estación         \\ \hline
PIDS-UC-02  & Elegir destino             \\ \hline
PIDS-UC-03  & Información de asistencia \\ \hline
PIDS-UC-04  & Receptor de tramas       \\ \hline
\end{tabular}
	\caption{Tabla de casos de uso.}
	\label{tab:UseCases}
\end{table}
\end{center}

El caso de uso UC-1 involucra al tren como sistema disparador cuando arriba a una estación y presenta información visual al pasajero usando los carteles LED de salón. El UC-2 resuelve una acción del conductor al presionar un botón, y presenta también información visual al pasajero, en este caso las estaciones cabecera del recorrido que se visualizan en los carteles LED de frente y contrafrente del tren. El tercer caso de uso, UC-3, presenta información de asistencia previamente cargada que se dispara por acción de un timer mientras el tren está en circulación. Por último, el caso de uso UC-4 involucra al módulo SCU (ver \ref{fig:diagramaPIDS} de la red PIDS y a un sistema externo, como puede ser una computadora de un operador u otro componente de la red, para decodificar las tramas de datos recibidas desde el SCU.\\


\begin{table}[]
\centering
\begin{tabular}{|lll|}
\hline
 
\multicolumn{3}{|l|}{{ \textbf{UC-1: Visualización del nombre de la estación arribada}}} \\ \hline
 
\multicolumn{1}{|r|}{{ 1}} & \multicolumn{1}{l|}{{ Nombre}} & { Visualizar el nombre de la estación arribada.} \\ \hline
 
\multicolumn{1}{|r|}{{ 1.1}} & \multicolumn{1}{l|}{{ Descripción}} & { El sistema genera un mensaje que contiene información para el pasajero y se lo presenta en una marquesina LED.} \\ \hline
 
\multicolumn{1}{|r|}{{ 1.2}} & \multicolumn{1}{l|}{{ Actor principal}} & { Pasajeros} \\ \hline
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ Disparadores}} & { El evento se inicia cuando el tren arriba a una estación.} \\ \hline
 
\multicolumn{1}{|r|}{{ 2}} & \multicolumn{1}{l|}{{ Flujo de eventos}} & { } \\ \hline
 
\multicolumn{1}{|r|}{{ 2.1}} & \multicolumn{1}{l|}{{ Flujo básico}} & { El tren comienza a frenar hasta llegar a velocidad 0 km/h.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema PIDS recibe del bus MVB las tramas con la variable de velocidad.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema PIDS busca el nombre de la estación actual, busca el nombre de la estación siguiente y genera la trama.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema PIDS envía la trama a la Red TCN con destino al subsistema HMI.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema HMI recibe la trama generada por el PIDS y presenta en display el mensaje a visualizar.} \\
\hline
 
\multicolumn{1}{|r|}{{ 2.2}} & \multicolumn{1}{l|}{{ Flujo alternativo}} & { El tren se queda detenido en la estación.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema PIDS recibe del bus MVB las tramas con la variable de velocidad.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema PIDS compara el estado actual y no detecta cambios.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema PIDS envía una trama a la red TCN interrogando al subsistema HMI por el mensaje que está se visualizando.} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema HMI recibe el requerimiento y entrega el mensaje que tiene cargado en el sistema al PIDS .} \\
 
\multicolumn{1}{|l|}{{ }} & \multicolumn{1}{l|}{{ }} & { El subsistema PIDS recibe el mensaje y no detecta cambios, no envía señales de cambio.} \\ \hline
 
\multicolumn{1}{|r|}{{ 3}} & \multicolumn{1}{l|}{{ Requerimientos especiales}} & { } \\ \hline
 
\multicolumn{1}{|r|}{{ 4}} & \multicolumn{1}{l|}{{ Pre-condiciones}} & { El sistema debe estar en modo ONLINE.} \\ \hline
 
\multicolumn{1}{|r|}{{ 5}} & \multicolumn{1}{l|}{{ Post-condiciones}} & { El sistema pasa al estado detenido.} \\ \hline
\end{tabular}
\caption{}
\label{tab:my-table}
\end{table}


\pagebreak
\newpage
\section{Arquitectura}

El sistema PIDS de Trenes Argentinos sigue una arquitectura que está relacionada con la implementación de la red TCN del fabricante de los trenes, la empresa China State Railway Group Company, Ltd. En este capítulo se describen los aspectos más relevantes de esa arquitectura que tienen relación con los componentes del sistema propuesto.\\

El sistema diseñado en este trabajo sigue una arquitectura orientada a eventos. Se desarrollaron e implementaron distintos patrones de software a lo largo del trabajo buscando satisfacer propiedades de modularidad, portabilidad y escalabilidad. Algunos de los objetos implementados se describen a nivel de detalle para resaltar criterios y decisiones de diseño relevantes. \\

La relación entre la arquitectura existente del PIDS de trenes y la arquitectura del sistema embebido basado en la plataforma CIAA busca satisfacer por un lado la compatibilidad eléctrica de hardware y por otro las historias de usuario planteadas en los casos de uso en la etapa de definición de requerimientos. \\

En las secciones siguientes se describen los componentes del sistema y sus interacciones. Se mencionan también algunas mejoras evaluadas para futuras implementaciones que buscan optimizar fragmentos de código con potencial de optimización de recursos usando instrucciones en lenguaje assembly propias de arquitecturas ARM M4.\\

\subsection{Contexto}

El sistema PIDS forma parte de una solución integral, la red de comunicaciones del tren o red TCN, brinda información a los pasajeros y puede ser operada por el conductor del tren o los operadores, tal como se representa en el diagrama de la figura \ref{fig:diagTrenTcnPids}.\\

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagTrenTcnPids.png}
	\caption{Diagrama del sistema Tren-TCN-PIDS.}
	\label{fig:diagTrenTcnPids}
\end{figure}

La red TCN define una comunicación estándar usando dos buses jerárquicos llamados WTB(Wire Train Bus) y MVB (Multifunction Vehicle Bus). El sistema PIDS se interconecta al bus de datos MVB, como se indica en el diagrama de la figura \ref{fig:diagTcnPidsBuusesWtbMvb}.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagTcnPidsBusesWtbMvb.png}
	\caption{Diagrama de interconexión TCN-PIDS}
	\label{fig:diagTcnPidsBuusesWtbMvb}
\end{figure}

El sistema PIDS tiene un bus de comunicación propio a través de una red RS485. Uno de los componentes de esta red es el módulo SCU, al cual se conectan distintos dispositivos como los display LED, los mapas de recorrido LED, las cámaras y parlantes, tal como se indica en la figura 	\ref{fig:diagPidsScuDevices}.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagPidsScuDevices.png}
	\caption{Diagrama del módulo SCU en la red PIDS.}
	\label{fig:diagPidsScuDevices}
\end{figure}

Al módulo SCU se conectan las unidades IDU, que corresponden a los display LED de salón. Cada unidad IDU contiene un driver y el arreglo de módulos de matriz de led que conforman el display. En la figura \ref{fig:diagScuDriverDisplay} se representan estos bloques funcionales.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/diagScuDriverDisplay.png}
	\caption{Diagrama de bloques del sistema SCU, placa de control y carteles LED de salón.}
	\label{fig:diagScuDriverDisplay}
\end{figure}

El alcance del sistema desarrollado en este trabajo cubre la funcionalidad de este conjunto de bloques Driver + Display, que en la nomenclatura del sistema PIDS existente corresponde a los módulos IDU. Existen dos unidades de estos módulos por cada salón o coche.\\

Comúnmente un tren tiene siete coches en las formaciones de SOFSE, por lo que se tiene un mínimo de catorce unidades IDU más dos displays externos adicionales para el frente y contrafrente del tren que indican las estaciones cabecera del recorrido. Esto resulta en un total de dieciséis unidades de control de display por cada tren. Teniendo en cuenta las formaciones operativas de las líneas Mitre, Sarmiento y Roca del Área Metropolitana de Buenos Aires (AMBA), se puede estimar alrededor de treinta trenes operando en simultáneo, lo que resulta en aproximadamente 500 unidades de displays operando en vivo. El impacto que puede tener el aporte de este trabajo estará directamente relacionado con la operación de Trenes Argentinos y definitivamente puede contribuir a la extensión de la vida útil de los trenes.\\

\subsection{Diseño}
La propuesta de diseño busca cubrir las funcionalidades del bloque de control del display LED. El display LED es una unidad que se puede adquirir comercialmente. Sin embargo el driver para la red PIDS es una solución propietaria del fabricante y es la que se busca reemplazar con este desarrollo.\\

En la figura \ref{fig:diagVistaReDisenhoEduCIAA} se presenta un diagrama de bloques del sistema de control propuesto. Este controlador usa comunicación serie a través de interfaces UART-RS485 y UART-USB. La UART es un periférico del microcontrolador de la plataforma CIAA. La alimentación de la CIAA difiere de aquella existente en la red RS485, por lo que también es necesario un bloque de conversión DC-DC para garantizar compatibilidad eléctrica. La comunicación con el display se realiza a través de un adaptador, que consiste básicamente en un puerto de entrada-salida.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figures/diagVistaReDisenhoEduCIAA.png}
	\caption{Diagrama de bloques del controlador propuesto.}
	\label{fig:diagVistaReDisenhoEduCIAA}
\end{figure}

A nivel lógico, el sistema que se propone consiste en cuatro objetos activos que interactúan entre sí, tal como se indica en la figura \ref{fig:diagVistaDisenho}. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/diagVistaDisenho.png}
	\caption{Vista de interacciones del sistema propuesto.}
	\label{fig:diagVistaDisenho}
\end{figure}

El objeto activo UART es el encargado de recibir e interpretar las tramas de datos que viajan por la red RS485 del bus de datos del SCU. El objeto activo fsmButton es el control manual del operador para accionar el sistema. El objeto activo fsmTrain es una máquina de estados que representa el estado del tren y es el que contiene los mensajes y nombres de las estaciones. El objeto activo Display es el encargado de codificar los mensajes en el formato correspondiente a la matriz led del display.\\

Esta vista de interacción entre objetos indica la dependencia funcional de los componentes del sistema. Su diseño modular permite hacer cambios en los componentes de sistema de forma independiente. Por ejemplo se podrían reemplazar los mensajes al pasajero en el objeto fsmTrain sin afectar el resto del sistema, o bien reemplazar la lógica de control del display si fuera necesario cambiar la tecnología de control del display led modificando únicamente el objeto Display.\\


\section{Implementación}
En este trabajo se implementa un sistema embebido en lenguaje C usando el sistema operativo de tiempo real freeRTOS sobre una arquitectura de 32 bits ARM Cortex-M4/M0. La plataforma de hardware elegida es la CIAA-EDU-NXP, que dispone de un microcontrolador LPC4337 de la companía NXP (\cite{NXPLPC4337}).\\
 
Se ha utilizado la \textit{SAPI} y el \textit{firmwareV3} \cite{firmwarev3}, como API que funciona como capa de abstracción de las funciones específicas de la biblioteca del fabricante del microcontrlador. Esta API es parte fundamental del proyecto CIAA.\\
 
En el desarrollo del firmware se ha preferido el uso de plantillas para implementar patrones de software como máquinas de estado y objetos activos, de manera que se facilite la documentación y testing y con ello el mantenimiento y la escalabilidad. Se describen los lineamientos y fragmentos de código principales en la sección de patrones de software.\\

Finalmente se dedica una sección a nivel de detalle para la implementación del controlador del diplay led. El firmware busca ser portable a aquellas versiones de hardware de display basadas en el conjunto de chips 74HC245, 74HC595 y 74HC138 o equivalentes de compuertas digitales. \\


\subsection{Organización del código fuente}
La organización del código fuente que conforma el sistema embebido de este trabajo se describe en el siguiente árbol de archivos:

\begin{lstlisting}[
	language=Bash, 
	backgroundcolor=\color{mygray},
	]
AppRTOS
|-- config.mk
|-- inc
|   |-- displayLed.h
|   |-- FreeRTOSConfig.h
|   |-- ISR_GPIO.h
|   |-- main.h
|   |-- modulePanelDisplay.h
|   |-- portmap.h
|   |-- statemachine_AB.h
|   |-- statemachine_button.h
|   |-- statemachine_displayLed.h
|   `-- userTasks.h
|-- LICENSE.txt
`-- src
    |-- displayLed.c
    |-- ISR_GPIO.c
    |-- main.c
    |-- statemachine_AB.c
    |-- statemachine_button.c
    |-- statemachine_displayLed.c
    `-- userTasks.c
\end{lstlisting}

Se pueden observar dos directorios principales: \textit{inc} y \textit{src}. En \textit{inc} se incluyen los archivos de encabezados y en \textit{src} los archivos de código ejecutable. Existe un archivo principal o \textit{main} que es el que instancia las secuencias de incialización, recursos y tareas del sistema operativo. Las tareas, entendidas como los objetos activos y procesos del sistema, se implementan en los archivos \textit{userTasks}. Luego, para cada implementación de objeto activo existe una máquina de estados asociada en un archivo de encabezados y un archivo ejecutable con el prefijo \textit{statemachine}. Finalmente los archivos con el prefijo \textit{ISR} corresponden a las rutinas de interrupción.\\

Esta organización permite encapsulamiento y modularidad entre componentes del sistema. Con ello se facilita el mantenimiento y con el uso de las mismas reglas de diseño y plantillas se facilita la escalabilidad.\\

\subsection{RTOS: Sistema operativo de tiempo real}

En este desarrollo se utiliza freeRTOS, una versión en C de un kernel de sistema operativo de tiempo real. La implementación se basa en la inclusión de los archivos FreeRTOS.h y FreeRTOSConfig.h. Esta implementación ha sido validada en arquitecturas ARM Cortex-M4, en particular en la plataforma EDU-CIAA. 

En todos los casos que fue posible se utilizaron semáforos, colas y mutex para organizar y proteger el uso compartido de recursos. \\

El caso de uso típico de \textit{mutex} es la interacción de distintas tareas con la misma interfaz UART-USB para imprimir mensajes por pantalla. En el código fuente de cada objeto implementado se utiliza la siguiente plantilla para proteger el recurso evitando accesos múltiples y posibilidad de deadlock:\\

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
if (pdTRUE == xSemaphoreTake( xMutexUART, portMAX_DELAY)){
   vPrintString("Task AB is running.\r\n");
   xSemaphoreGive(xMutexUART);
}
\end{lstlisting}

Las colas, \textit{Queue}, se utilizan principalmente para comunicar eventos entre objetos activos. En todos los casos se referencian con handlers usando la nomenclatura con prefijo \textit{queueHandle}. En el siguiente fragmento de código se muestra un ejemplo, exibiendo los mecanismos de control de errores usados. \\

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
queueHandle_button = xQueueCreate(QUEUE_MAX_LENGTH, sizeof(eSystemEvent_button));
if (queueHandle_button == NULL){
    perror("Error creating queue");
    return 1;
}
\end{lstlisting}


Todas las tareas y recursos del sistema operativo se han protegido contra errores informando al usuario ante fallas en la instanciación previas al inicio del scheduler.

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
if( xTaskCreate( vTaskReadSerial, "Serial Comm reading task", 
    configMINIMAL_STACK_SIZE*4, NULL, tskIDLE_PRIORITY+2, &xTaskReadSerialHandler) 
    == pdFAIL ) {
    perror("Error creating task");
}
\end{lstlisting}

Se utilizan también punteros de tipo \textit{xTaskHandle}para referenciar las tareas del sistema operativo. Este tipo de referencias es de especial utilidad a la hora de crear o eliminar tareas de forma dinámica en tiempo de ejecución. También es posible usar estas referencias para comunicación interprocesos, o entre tareas.\\

También se utilizan \textit{Timers} por software en aquellos casos que su uso facilita el mantenimiento, legibilidad y comprensión de la implementación. Especial cuidado de superposición o competición del reloj del sistema operativo se procura al disponer de componentes que tienen requisitos temporales que compiten entre si por prioridad del scheduler. Se verá en detalle la implementación del display Led como ejemplo.\\

Las rutinas de interrupción por hardware o \textit{ISR} se utilizan cuando se requiere respuesta inmediata, como al accionar manualmente un interruptor o bien al recibir mensajes o señales eléctricas desde el bus de datos del tren. La implementación elegida para el uso de interrupciones se representa en el diagrama de secuencia de la figura \ref{fig:ISR}. \\

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/ISR_semaphore.png}
	\caption{Diagrama de secuencia que representa la interacción entre componentes del sistema operativo cuando se dispara una interrupción o ISR.}
	\label{fig:ISR}
\end{figure}

El recurso de hardware que genera interrupciones (ISR) llama a una función callback (\textit{ISR callback}) que sólo se encarga de entregar un semáforo al sistema, no tiene lógica implementada, sólo avisa al sistema que hay una interrupción que atender. El semáforo es tomado por una tarea de sistema (vHandlerTask) que resuelve el código de ejecución. Esta tarea normalmente implementa un objeto activo que actualiza una máquina de estado.\\

De esta manera se logra atomicidad en las rutinas de interrupción y con ello muy baja latencia, se desacopla la invocación de la ejecución usando callback y callee en dos hilos independientes y se mantiene consistencia en el uso de objetos activos siguiendo los lineamientos de la arquitectura orientada a eventos.\\


Memoria dinámica.


\subsection{Patrones de software}
En este desarrollo se ha hecho uso extensivo de los patrones máquina de estado, objeto activo, pipeline, observ and react, y superciclo. Se presenta en detalle el formato de plantillas desarrollado en C para freeRTOS.\\

\subsubsection{Máquinas de estado}
El desarrollo de la arquitectura orientada a eventos propuesta se basa en la interacción de máquinas de estado usando objetos activos. En este trabajo las máquinas de estado se implementan sistemáticamente en C con el siguiente procedimiento paso a paso:

\begin{enumerate}
\item Representar los estados y eventos con un diagrama de máquina de estados.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.66\textwidth]{./Figures/statemachineAB.png}
	\caption{Diagrama de la máquina de estados AB ejemplo.}
	\label{fig:fsmAB}
\end{figure}

\item Definir los estados. Usar tipo enumerativo definido con el prefijo \textit{eSystemState}:

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef enum{

    STATE_INIT,
	STATE_A,
	STATE_B

} eSystemState;
\end{lstlisting}

\item Definir los eventos. Los eventos representan transiciones entre estados con un tipo definido con el prefijo \textit{eSystemEvent}:

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef enum{

	evInit,
	evTimeout

} eSystemEvent;
\end{lstlisting}

\item Definir un tipo puntero a función para designar los handlers con el prefijo \textit{*pfEventHandler()}:

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef eSystemState (*pfEventHandler)(void);
\end{lstlisting}

\item Definir una estructura para la máquina de estados con un tipo \textit{sStateMachine}. Esta estructura debe incluir una variable estado (eSystemState), una variable evento (eSystemEvent) y un puntero a función (pfEventHandler). El puntero a función será una instancia de handler específico que maneje las transiciones entre estados. 

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
typedef struct{

	eSystemState  	fsmState;
	eSystemEvent  	fsmEvent;
	pfEventHandler	fsmHandler;

} sStateMachine;
\end{lstlisting}

\item Definir los handlers a implementar para el manejo de ejecución y transiciones entre estados.

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
eSystemState 	InitHandler(void);
eSystemState 	AtoBHandler(void);
eSystemState 	BtoAHandler(void);
\end{lstlisting}

\item Instanciar la máquina de estados como un arreglo de estructuras de tipo \textit{sStateMachine}. Para el ejemplo de la máquina AB la instancia de arreglo de estructuras sería la siguiente:

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
sStateMachine_AB fsmMachineAB [] = 
{
	{STATE_INIT_AB, evInit_AB, InitHandler_AB},
	{STATE_A, evTimeout_A, AtoBHandler},
	{STATE_B, evTimeout_B, BtoAHandler}
};
\end{lstlisting}

\item Escribir el código ejecutable de los handlers. Una implementación de handler a modo de ejemplo se presenta a continuación.

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
eSystemState 	InitHandler(void){ 
	printf("State Machine Init...\n");
	return STATE_A; 
}
\end{lstlisting}

\end{enumerate}

De esta manera queda desacoplada la implentación de los handlers del resto de la estructura de la máquina de estados, logrando portabilidad, escala y modularidad. Los handlers serán funciones que se implementan con el sufijo Handler() y que por definición tienen un solo argumento de tipo void.

Con esta técnica de desacoplamiento, se implementan dos archivos por cada máquina de estado : uno de encabezados (stateMachine.h) con las definiciones y otro con la implementación (stateMachine.c) de los handlers.




\subsubsection{Objeto Activo}
	
Los objetos activos se implementan en esta aplicación como tareas de freeRTOS con dos superciclos anidados de tipo \textit{while(true)}, como se muestra en el siguiente fragmento de código: 

\begin{lstlisting}[
	language=C, 
	backgroundcolor=\color{mygray},
	]
void vTaskAB(void *xTimerHandle)
{
   (void)xTimerHandle;

   // Task successful creation message
   if (pdTRUE == xSemaphoreTake( xMutexUART, portMAX_DELAY)){
      printf("Task AB is running.\r\n");
      xSemaphoreGive(xMutexUART);
   }

   while(true){
      
      // State machine init
      eSystemEvent_AB newEvent	=	evInit_AB;
      eSystemState_AB nextState	=	STATE_INIT_AB;
      fsmMachineAB[nextState].fsmEvent = newEvent; 
      nextState = (*fsmMachineAB[nextState].fsmHandler)();

      // Active object
      while(true){
        if( pdPASS == xQueueReceive(queueHandle_AB, &newEvent, portMAX_DELAY)){
            fsmMachineAB[nextState].fsmEvent = newEvent; 
            nextState = (*fsmMachineAB[nextState].fsmHandler)();
         }
      }
   }
}
\end{lstlisting}

Notar que el primer ciclo while() es el que corresponde al funcionamiento normal de una tarea o proceso de RTOS. En este caso es el encargado de inicializar la máquina de estados asociada al objeto activo. El superciclo while() de la línea 20 se encarga de bloquear la tarea hasta que se reciba un evento por la interfaz (cola de eventos). La interfaz del objeto activo es una cola FIFO con la función de sistema xQueueReceive() (línea 21). Si se recibe un evento, entonces se actualiza el estado de la máquina instanciando el handler que corresponda, como se observa en la línea 25. El diagrama de la figura \ref{fig:AOfsmAB} representa el objeto activo detallado. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.85\textwidth]{./Figures/AOstatemachineAB.png}
	\caption{Diagrama del objeto activo de la máquina de estados AB ejemplo.}
	\label{fig:AOfsmAB}
\end{figure}

En este caso la tarea recibe una referencia a un timer (\textit{xTimerHandle}) que genera eventos de timeout y los encola en la interfaz del objeto activo. Con la misma interfaz, los eventos podrían ser generados también por otros objetos activos o por rutinas de interrupción, tal como se indica en la figura.\\




\pagebreak
\subsection{Componentes de sistema}

En esta sección se describen los componentes principales de la solución representada con el diagrama de la figura \ref{fig:diagVistaDisenho}. Los cuatro objetos activos utilizados son:\\
\begin{itemize}
\item \textbf{UART}: objeto activo que sirve de interfaz de comunicación con la red RS485 del sistema PIDS. Se encarga de recibir los mensajes de la red, identificarlos y enviarlos al PIDS.
\item \textbf{PIDS}: objeto activo responsable de la lógica entre las señales del tren como mensajes de entrada y la configuración de mensajes de salida que se visualizan en pantalla. 
\item \textbf{displayLED}: objeto activo responsable de codificar los mensajes que vienen del PIDS para ser visualizados en un display de matriz led a través de un hardware de control.
\item \textbf{Button}: objeto activo responsable de recibir accionamientos manuales del conductor del tren.
\end{itemize}

Las interacciones entre componentes se presentan con los diagramas de secuencia de la figura \ref{fig:diagramaSecuenciaSistema} que representan los casos de uso.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{../Figures/secuenciasSistema.png}
	\caption{(a)caso de uso de visualización de estación; (b) caso de uso de receptor de tramas;(c) caso de uso de elección de destino por accionamiento del conductor;(d) caso de uso de visualización de información de asistencia.}
	\label{fig:diagramaSecuenciaSistema}
\end{figure}


La organización del scheduler del sistema operativo se representa con el diagrama temporal de la figura \ref{fig:diagramasTemporales}. La base de este diagrama es el orden de prioridades de las tareas de objetos activos, los timers y los handlers de interrupciones que manejan los periféricos de hardware.\\


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{./Figures/diagramasTemporales.png}
	\caption{}
	\label{fig:diagramasTemporales}
\end{figure}

\subsection{Display LED}

El objetivo de esta sección es describir la solución implementada para el manejo de carteles de matriz led, su estructura, su forma de uso y cómo se debe modificar en caso de reutilización en otros sistemas.\\

Los carteles led que se utilizaron en esta solución tienen una tecnología de control específica, que incluye un MCU y un sistema digital. La topología del sistema digital se presenta con el diagrama de la figura \ref{fig:diagDriverLED}.\\

\begin{figure}[ht]
	\centering
	\includegraphics[]{./Figures/diagDriverLED.png}
	\caption{Diagrama de bloques del controlador de los carteles de matriz LED utilizados en esta implementación.}
	\label{fig:diagDriverLED}
\end{figure}

Los módulos display led utilizados en este desarrollo se componen de una matriz de 8x8 leds. Estos módulos se deben direccionar por filas y columnas para  visualizar información. Los arreglos de estos módulos forman lo que se conoce como paneles, que para sistemas digitales de este tipo pueden ser direccionados por un conjunto de señales de control.\\

Las señales de control (data, clock, latch, deco) se generan en el MCU y se transmiten al circuito eléctrico a través de un conector (CONN). Estas señales se direccionan eléctricamente usando buffers. Luego, hacia la izquierda, se transmiten las señales data, clock y latch, que envían los datos del mensaje codificado a un arreglo de Shift Registers. Estos últimos son los encargados de transmitir bit a bit los datos de cada columna que forma una fila del cartel. Una vez enviados todos los datos de una fila, se envía un pulso como señal de latch y se energiza la fila completa. Se repite la operación fila a fila escaneando todo el cartel a través de las señales del Deco, energizando cada fila a través de un arreglo de transistores MOSFET que mantienen la corriente necesaria para encender los leds. Este encendido por fila sucede durante un tiempo equivalente de forma tal que toda la pantalla se pueda energizar en el orden de 20 a 50 veces por segundo para formar una imagen continua al ojo humano.\\

En el circuito esquemático de la figura \ref{fig:schDriverLED} se presenta el detalle de conexiones eléctricas entre bloques. Se puede observar que a la salida del conector de datos (CONN 2x8) hay dos buffers de la serie 74HC245D que direccionan las señales eléctricas a izquierda y derecha del arreglo de matrices led. A izquierda viajan las señales SER(data), SRCLK (Clock) y XXX (latch) al arreglo de Shift Registers de la serie 74HC595. Por la derecha se maneja la habilitación secuencial de las filas a través de un arreglo de decodificadores 3x8 de la serie 74HC138. Cada salida de los decodificadores se conecta a un driver de corriente en arreglo de transistores MOSFET FDS4953. Estos decodificadores cableados adecuadamente permiten manejar las 32 señales de un cartel de 4x8 módulos led. 

\begin{figure}[ht]
	\centering
	\includepdf[angle=90]{./Figures/output.driverLED.pdf}
	\caption{Circuito esquemático de la placa controladora de los carteles de matriz LED.}
	\label{fig:schDriverLED}
\end{figure}

Los arreglos de paneles forman carteles. En este trabajo se desarrolló un sistema de control digital para carteles de 4x8 \\




\begin{figure}[ht]
	\centering
	\includegraphics[width=0.75\textwidth, angle=270]{./Figures/cartel4x8.jpg}\\
	\includegraphics[width=1\textwidth]{./Figures/cartel2x6.jpeg}
	\caption{Fotografías de la placa de control de los carteles de matriz LED: (a) placa de 4x8 módulos; (b) placa de 2x6 módulos}
	\label{fig:picsDriverLED}
\end{figure}



\subsection{Controlador}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/output.placaControl.pdf}
	\caption{Circuito esquemático de la placa de control de los carteles LED de salón.}
	\label{fig:schController}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{./Figures/displayDataLogic.png}
	\caption{Lógica de procesamiento de datos para visualizar en el display.}
	\label{fig:displayDataLogic}
\end{figure}


\subsection{Interfaces}
\subsection{Vistas de sistema}
